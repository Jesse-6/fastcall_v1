This is an important change on how fastcall_v1 macro works, as of the aformentioned date.
From now on, executables generated using this macro toolkit has auto alignment to sane (and safer) values by default. Changes are as follows:

 - '_code' segment now defaults at 4-byte alignment. If it has anonymous strings inside code section, and no other section for data output, it aligns this data at 16-byte, and the topmost (i.e., first) line of code at 4-byte;
 - _data and _rdata segments now defaults at 64-byte alignment, which is the size of a ZMM register at processor, which in turn is the largest size a processor can access at once in one instruction;
 - _bss (uninitialized data) segment now defaults at 64-byte alignment, the same reason above.

Important: subsequent uses of _data, _rdata and/or _code statements does not align further! Only the first is aligned! Following the "appending" method on how they work.
 
Overrides are still working as before, so, to change alignments, just do any of:

   _code align XX
   _bss align XX
   _data align XX
   _rdata align XX
   
Also, the 'interpreter' section and "import" sections has now fixed (unchangeable) 8-byte alignment, ensuring no "broken offsets" for important qword parameters at those sections that define de final ELF executable.

This is compliant to the 'alignment check specification' used by the processor. See x86-64 processor manual to properly understand this feature, and the reason why I made this change.

Some of new alignments, except for 'interpreter' section, has a visible byte "footprint" which can be visualized to see (in a hex editor) the padding applied. See the macro source code for that bytes.

Believe me, the few extra bytes generated by this change worths its value, ensuring better quality to final executables that, indeed, is what I noticed after, is a default behavior with nasm generated executables.
